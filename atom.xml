<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Matthias Georgi</title>
  <id>http://www.matthias-georgi.de</id>
  <updated>26 Jan 14 00:00</updated>
  <entry>
    <id>http://www.matthias-georgi.de2013_01_29_how-to-write-a-blog-engine-in-haskell-part-2.html</id>
    <title type="text">How to write a blog engine in Haskell Part 2</title>
    <updated>29 Jan 13 00:00</updated>
    <content type="html">&lt;p&gt;In &lt;a href=&quot;how-to-write-a-blog-engine-in-haskell-part-1.html&quot;&gt;my last post&lt;/a&gt; layed out the top level structure of the blog
engine, how to find the right files from the posts folder and how to
represent posts as data types.&lt;/p&gt;

&lt;p&gt;This time I&amp;#39;d like to introduce a type-safe way to render HTML
directly in Haskell without sacrificing readability or ease of use.&lt;/p&gt;

&lt;p&gt;There are probably a million ways to render HTML but in practice there
are only a handful of possibilities you might consider for putting
data into HTML code.&lt;/p&gt;

&lt;h2&gt;Template Languages&lt;/h2&gt;

&lt;p&gt;The most popular way of rendering HTML are good old PHP-style
templates, which let you interleave HTML code with executable bits of
a dumb language to fill in dynamic values. This is a straight-forward
approach which gets the job done but certainly has some
disadvantages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You might want to validate your HTML during development.  As the
template language itself is not a subset of HTML you can&amp;#39;t vaidate the
template itself so easily.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reusable code lives as helper function which just returns dumb strings
instead of data structures leading to error-prone code.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In general no type checking which makes it hard to build
abstractions on top of some rendering logic.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Blaze Html&lt;/h2&gt;

&lt;p&gt;Let me introduce the &lt;a href=&quot;http://jaspervdj.be/blaze/&quot;&gt;BlazeHtml&lt;/a&gt; HTML combinator library for
Haskell. It&amp;#39;s incredible simple to use, always generates valid HTML,
offers type-safety and is blazingly fast as the name already states.&lt;/p&gt;

&lt;p&gt;Have a look at the type signature of a typical HTML combinator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a :: Html -&amp;gt; Html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function takes an &lt;code&gt;Html&lt;/code&gt; element as content for a tag and returns
another &lt;code&gt;Html&lt;/code&gt; element, which represents a link in this case.&lt;/p&gt;

&lt;p&gt;A more complete example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Text.Blaze.Html5
import Text.Blaze.Html5.Attributes

renderPage = docTypeHtml $ do
  body $ do
    ul $ forM_ [1 .. 10] (li . toHtml)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;renderPage&lt;/code&gt; generates HTML for a list with numbers from 1 to 10.
Note that you don&amp;#39;t have any impedance mismatch between HTML and
the host language. Code and data is easily mixed without losing
type-safety. This is a big deal for me. Just imagine all the time
you lost while reloading a web page after some minor editing just
to see you have to switch back to your editor again.&lt;/p&gt;

&lt;h2&gt;Rendering Posts with Sundown&lt;/h2&gt;

&lt;p&gt;Rendering of posts should be simple and straighforward as possible.
A blog post is just a regular markdown file with a title as first
line. So to convert a blog post into html we basically just convert
the file via &lt;a href=&quot;http://hackage.haskell.org/package/sundown&quot;&gt;Sundown&lt;/a&gt;, the markdown library from Github, and
insert the resulting HTML into a layout template.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{-# LANGUAGE OverloadedStrings #-}
import Text.Blaze.Html4.Strict hiding (head, map, title, contents)
import Text.Blaze.Html4.Strict.Attributes hiding (content, title)
import qualified Text.Blaze.Html4.Strict as H
import qualified Text.Blaze.Html4.Strict.Attributes as A
import Text.Sundown.Html.String as S
import Data.List.Split

data Blog = Blog {
  blogUri,
  blogTitle :: String
};

data Post = Post {
  postFolder,
  postFile,
  postText:: String
};

-- Take the first line of a post file as post title.
postTitle :: Post -&amp;gt; String
postTitle post = head $ lines $ postText post

-- Return the filename of the post without extension.
postName :: Post -&amp;gt; String
postName post = head $ splitOn &amp;quot;.&amp;quot; $ postFile post

-- Returns the path to the post on the website.
postLink :: Post -&amp;gt; String
postLink post = &amp;quot;/&amp;quot; ++ (postFolder post) ++ &amp;quot;/&amp;quot; ++ (postName post) ++ &amp;quot;.html&amp;quot;

-- Returns just the rendered body of a post without title.
postBody :: Post -&amp;gt; String
postBody post = S.renderHtml s allExtensions noHtmlModes True Nothing
  where s = concat $ intersperse &amp;quot;\n&amp;quot; $ drop 3 $ lines $ postText post

-- Render the html layout, insert the blog title, post title and post content.
renderLayout :: Blog -&amp;gt; Html -&amp;gt; Html
renderLayout blog content = do
  docType
  html $ do
    H.head $ do
      H.title $ toHtml $ blogTitle blog
    body $ do
      h2 ! id &amp;quot;header&amp;quot; $ do
        a ! href &amp;quot;/&amp;quot; $ toHtml $ blogTitle blog
      div ! class_ &amp;quot;content&amp;quot; $ do
        preEscapedToHtml content

-- Render a single post.
renderPost :: Post -&amp;gt; Html
renderPost post =
  div ! class_ &amp;quot;article&amp;quot; $ do
    h1 $ do
      a ! href (toValue (postLink post)) $ toHtml $ postTitle post
    preEscapedToHtml $ postBody post

-- Render a complete page containing one post.
renderPostPage :: Blog -&amp;gt; Post -&amp;gt; String
renderPostPage blog post = H.renderHtml $ renderLayout blog $ renderPost post
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BlazeHtml escapes any value by default to prevent XSS. So any value
you want to insert has to be of type &lt;code&gt;Html&lt;/code&gt; or &lt;code&gt;AttributeValue&lt;/code&gt;. Look
at the code for the post title inside &lt;code&gt;renderPost&lt;/code&gt;. The href for the link
needs to be converted and the text of the link as well.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;preEscapedToHtml&lt;/code&gt; is an explicit way to insert raw strings into the HTML
document. In our case it is used to insert the page content into the 
layout and to insert the rendered markdown into the post template.&lt;/p&gt;

&lt;h2&gt;Atom and RSS feeds&lt;/h2&gt;

&lt;p&gt;Next post we will have a look at rendering feeds with the &lt;a href=&quot;http://hackage.haskell.org/package/feed-0.3.8&quot;&gt;feed&lt;/a&gt;
package. &lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de2013_01_29_how-to-write-a-blog-engine-in-haskell-part-2.html" type="text/html" />
    <published>29 Jan 13 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2013_01_12_how-to-write-a-blog-engine-in-haskell-part-1.html</id>
    <title type="text">How to write a blog engine in Haskell Part 1</title>
    <updated>12 Jan 13 00:00</updated>
    <content type="html">&lt;p&gt;I really like to evaluate programming languages based on their
practical value and one of the fun tasks is to write a small static
file blog engine. The engine just converts a bunch of markdown files
which are sorted into folders by month and year to html files given a
set of simple templates.&lt;/p&gt;

&lt;h2&gt;Top level structure&lt;/h2&gt;

&lt;p&gt;Basically the rendering of blog posts can be done in three steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find all files that contain blog posts&lt;/li&gt;
&lt;li&gt;Read the markdown files into records&lt;/li&gt;
&lt;li&gt;Render each file to html and write to disk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In Haskell these steps could be written as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;writeBlog :: IO ()
writeBlog = do
  files &amp;lt;- findFiles &amp;quot;posts&amp;quot;
  posts &amp;lt;- mapM readPost files
  mapM_ writePost posts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When working inside the IO monad, you will use &lt;code&gt;mapM&lt;/code&gt; and &lt;code&gt;mapM_&lt;/code&gt;
quite often, similar to &lt;code&gt;map&lt;/code&gt; they have following type signatures:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapM :: Monad m =&amp;gt; (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m [b]
mapM_ :: Monad m =&amp;gt; (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They apply a monadic operation &lt;code&gt;a -&amp;gt; m b&lt;/code&gt; to each element of a list
and either you want to keep the result of each operation (mapM) or not
(mapM_).&lt;/p&gt;

&lt;p&gt;Interestingly there is a more generalized version in &lt;code&gt;Data.Traversable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Monad m, Traversable t) =&amp;gt; (a -&amp;gt; m b) -&amp;gt; t a -&amp;gt; m (t b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function applies the monadic operation to anything that is
traversable. So you could build a tree data type and declare it as
instance of &lt;code&gt;Data.Traversable&lt;/code&gt; and use this function to apply the
operation while maintaining the tree structure. For example a tree
of files would be converted into a tree of blog posts.&lt;/p&gt;

&lt;h2&gt;Find files&lt;/h2&gt;

&lt;p&gt;So the first step in the blog rendering process would be to find all
files containing a post. So I created a folder named &lt;code&gt;posts&lt;/code&gt; which
contains folders for each year, which in turn contain folders for each
month, which finally contain all the blog posts.&lt;/p&gt;

&lt;p&gt;What we want now is the same as the UNIX command &lt;code&gt;find posts -type f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This can be done by looking at the entries of a folder and entering
each sub folder to examine its contents. When we find a file, we
collect it into a result list, which will contain all files
eventually.&lt;/p&gt;

&lt;p&gt;When dealing with tree structures like a file system, recursion is an
elegant alternative to iteration. For each folder we find, the function
should call itself recursively until it ends up at the bottom most
level containing the files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;findFiles :: FilePath -&amp;gt; IO [FilePath]
findFiles path = do
  isFile &amp;lt;- doesFileExist path
  if isFile then
      return [path]
    else do
      entries &amp;lt;- getEntries path
      paths &amp;lt;- return $ map (\ entry -&amp;gt; path ++ &amp;quot;/&amp;quot; ++ entry) entries
      files &amp;lt;- mapM findFiles paths
      return $ concat files
  where
    getEntries filepath = do
      contents &amp;lt;- getDirectoryContents filepath
      return $ filter ((/= &amp;#39;.&amp;#39;) . head) contents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;findFiles&lt;/code&gt; takes a &lt;code&gt;FilePath&lt;/code&gt; and returns all files found in this
folder or its subfolders. When you pass a file it will just return a
list with this one file.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getEntries&lt;/code&gt; is a small helper function which returns all entries of
a folder without &amp;#39;.&amp;#39; and &amp;#39;..&amp;#39;.&lt;/p&gt;

&lt;p&gt;The else branch works like this: it reads all entries of the folder,
prepends the current path, recurses for each entry, collects the
return values and flattens them into one big list.&lt;/p&gt;

&lt;h2&gt;Reading posts into records&lt;/h2&gt;

&lt;p&gt;The data type representing a post is super simple. It just contains
the &lt;code&gt;folder&lt;/code&gt; (e.g. &amp;ldquo;posts/2012/12&amp;rdquo;), the &lt;code&gt;file&lt;/code&gt; (e.g. &lt;code&gt;post-title.md&lt;/code&gt;)
and the &lt;code&gt;text&lt;/code&gt; of the post.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data Post = Post { folder, file, text :: String };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;readPost&lt;/code&gt; therefore takes a &lt;code&gt;FilePath&lt;/code&gt; and reads the file contents,
decomposing the path name into &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, which we
feed into the record constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;readPost :: FilePath -&amp;gt; IO Post
readPost path = do
  s &amp;lt;- readFile path
  let [_, year, month, filename] = splitOn &amp;quot;/&amp;quot; path in
    return Post { folder = year ++ &amp;quot;/&amp;quot; ++ month, file = filename, text = s }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;splitOn&lt;/code&gt; is taken from the &lt;code&gt;Data.List.Split&lt;/code&gt; module in the &lt;code&gt;split&lt;/code&gt; package
and splits a string into a list of strings given a delimiter string.&lt;/p&gt;

&lt;h2&gt;To be continued&lt;/h2&gt;

&lt;p&gt;Next part in this series will take a look at the actual rendering of blog
post using the &lt;code&gt;sundown&lt;/code&gt; package.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de2013_01_12_how-to-write-a-blog-engine-in-haskell-part-1.html" type="text/html" />
    <published>12 Jan 13 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2011_08_24_quick-guide-for-passenger-on-natty-narwhal.html</id>
    <title type="text">Quick Guide for Passenger on Natty Narwhal</title>
    <updated>24 Aug 11 00:00</updated>
    <content type="html">&lt;p&gt;This is a short guide for installing &lt;a href=&quot;http://www.modrails.com/&quot;&gt;Phusion Passenger&lt;/a&gt; and &lt;a href=&quot;http://www.rubyenterpriseedition.com/&quot;&gt;Ruby
Enterprise Editition&lt;/a&gt; on Ubuntu Natty Narwhal. Depending on your machine
this will take 30-60 minutes on a fresh Ubuntu install.&lt;/p&gt;

&lt;h3&gt;Installing build tools and libraries&lt;/h3&gt;

&lt;p&gt;First we need to install the compiler toolchain (make, gcc and libc)
and necessary libraries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install build-essential zlib1g-dev libssl-dev libreadline5-dev libmysqlclient-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Ruby Enterprise Edition&lt;/h3&gt;

&lt;p&gt;We are going to download and compile Ruby Enterprise Edition. The
installer asks for the target directory.  I would recommend to install
into /opt/ruby unless you want to host different versions on this machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://rubyenterpriseedition.googlecode.com/files/ruby-enterprise-1.8.7-2011.03.tar.gz
$ tar xzf ruby-enterprise-1.8.7-2011.03.tar.gz
$ cd ruby-enterprise-1.8.7-2011.03
$ ./installer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we include the path to the ruby binaries in /etc/environment. It should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=&amp;quot;/opt/ruby/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After relogin you should be able to type ruby -v and get a response like this:    &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby 1.8.7 (2011-02-18 patchlevel 334) [x86_64-linux], MBARI 0x6770, Ruby Enterprise Edition 2011.03
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Apache and Passenger&lt;/h3&gt;

&lt;p&gt;We need to install Apache and necessary development libraries to compile Phusion Passenger. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install libcurl4-openssl-dev apache2-mpm-prefork apache2-prefork-dev libapr1-dev libaprutil1-dev
$ passenger-install-apache2-module
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Apache configuration&lt;/h3&gt;

&lt;p&gt;The compilation of the Passenger Apache
module finished with an instruction for your httpd.conf. Depending on
you passenger version, you will get something like this, which you add
to your &lt;code&gt;/etc/apache2/httpd.conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoadModule passenger_module /opt/ruby/lib/ruby/gems/1.8/gems/passenger-3.0.7/ext/apache2/mod_passenger.so
PassengerRoot /opt/ruby/lib/ruby/gems/1.8/gems/passenger-3.0.7
PassengerRuby /opt/ruby/bin/ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you browse to your url, you should see the standard apache &amp;ldquo;It works&amp;rdquo; page.&lt;/p&gt;

&lt;h3&gt;MySQL&lt;/h3&gt;

&lt;p&gt;The Ruby Enterprise Installer already compiled Ruby&amp;#39;s mysql client
library, now we need the server and client.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install mysql-server mysql-client
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Virtual host config&lt;/h3&gt;

&lt;p&gt;Adding a virtual host for your rails application is easy. Assuming
that your application resides in /var/www/myapp create a file named
&lt;code&gt;/etc/apache2/sites-available/myapp&lt;/code&gt; and fill in :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    ServerName myserver.com
    DocumentRoot /var/www/myapp/public
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we disable the default site and add our new virtual host:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ a2dissite default
$ a2ensite myapp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After restarting Apache your Rails application should run on Apache:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /etc/init.d/apache2 restart
&lt;/code&gt;&lt;/pre&gt;
</content>
    <link href="http://www.matthias-georgi.de2011_08_24_quick-guide-for-passenger-on-natty-narwhal.html" type="text/html" />
    <published>24 Aug 11 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2011_06_22_vtouch-control-ableton-live-in-a-webbrowser.html</id>
    <title type="text">vTouch - Control Ableton Live in a Webbrowser</title>
    <updated>22 Jun 11 00:00</updated>
    <content type="html">&lt;p&gt;VTouch is a multitouch browser frontend for Ableton Live. Inside your
webbrowser you can control clip triggering, volume, send and return
levels, mute, solo, record states. This works also on the network, so
you can connect your mobile phone, iPads or android tablets easily by
just browsing to you local webserver.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.matthias-georgi.de/images/vtouch.gif&quot; alt=&quot;vTouch&quot;&gt;&lt;/p&gt;

&lt;h3&gt;Screencast&lt;/h3&gt;

&lt;iframe width=&quot;425&quot; height=&quot;349&quot; src=&quot;http://www.youtube.com/embed/qFmiIcgRIao&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h3&gt;About the Hack&lt;/h3&gt;

&lt;p&gt;Ableton Live is an digital audio workstation, which is well suited for
live performances. Lots of parameters can be manipulated, midi or
audio loops can be triggered. Unfortunately it is cumbersome to use
this software with a touch device. A user interface specifically
designed to be used on multitouch devices, which is also portable
across platforms, offers many benefits and possibilities. Imagine a
whole band jamming on iPads with ohne live setup over a wireless
network.&lt;/p&gt;

&lt;h3&gt;Technology used&lt;/h3&gt;

&lt;p&gt;The frontend is rendered on HTML5 Canvas and communicates with a
nodejs server via websockets. On the backend the webserver talks to a
running ableton live instance and sends updates to all connected
clients.&lt;/p&gt;

&lt;p&gt;The canvas frontend is supported on all modern browsers including
apple mobile safari and android browsers. We created a small widget
library named canvas.ui to take care of multitouch events, rendering
and layout management.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de2011_06_22_vtouch-control-ableton-live-in-a-webbrowser.html" type="text/html" />
    <published>22 Jun 11 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2011_06_11_emacs-dark-theme.html</id>
    <title type="text">Emacs Dark Theme</title>
    <updated>11 Jun 11 00:00</updated>
    <content type="html">&lt;p&gt;Recently I updated my Emacs setup and decided to go for a more minimal
color theme. Especially on long coding nights you want a theme without
distracting colors.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.matthias-georgi.de/images/emacs-dark-theme.png&quot; alt=&quot;Emacs dark theme&quot;&gt;&lt;/p&gt;

&lt;h3&gt;Configuration&lt;/h3&gt;

&lt;p&gt;Just paste this code into your emacs condiguration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (set-face-attribute &amp;#39;default nil
                     :background &amp;quot;grey20&amp;quot;
                     :foreground &amp;quot;grey90&amp;quot;)

 (set-face-attribute &amp;#39;modeline nil
                     :background &amp;quot;grey10&amp;quot;
                     :foreground &amp;quot;grey90&amp;quot;)

 (set-face-attribute &amp;#39;cursor nil
                     :background &amp;quot;white&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-builtin-face nil
                     :foreground &amp;quot;grey60&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-comment-face nil
                     :foreground &amp;quot;grey60&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-constant-face nil
                     :foreground &amp;quot;grey60&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-keyword-face nil
                     :foreground &amp;quot;white&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-string-face nil
                     :foreground &amp;quot;white&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-variable-name-face nil
                     :foreground &amp;quot;lightblue&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-function-name-face nil
                     :foreground &amp;quot;lightblue&amp;quot;)

 (set-face-attribute &amp;#39;region nil
                     :background &amp;quot;#111&amp;quot;)                    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Additional faces&lt;/h3&gt;

&lt;p&gt;If you use speedbar or elscreen, you can set additional faces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(set-face-attribute &amp;#39;speedbar-file-face nil
                    :foreground &amp;quot;white&amp;quot;)

(set-face-attribute &amp;#39;elscreen-tab-background-face nil
                    :background &amp;quot;grey10&amp;quot;
                    :foreground &amp;quot;grey90&amp;quot;)

(set-face-attribute &amp;#39;elscreen-tab-control-face nil
                    :background &amp;quot;grey20&amp;quot;
                    :foreground &amp;quot;grey90&amp;quot;)

(set-face-attribute &amp;#39;elscreen-tab-current-screen-face nil
                    :background &amp;quot;grey20&amp;quot;
                    :foreground &amp;quot;grey90&amp;quot;)

(set-face-attribute &amp;#39;elscreen-tab-other-screen-face nil
                    :background &amp;quot;grey30&amp;quot;
                    :foreground &amp;quot;grey60&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</content>
    <link href="http://www.matthias-georgi.de2011_06_11_emacs-dark-theme.html" type="text/html" />
    <published>11 Jun 11 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2009_07_23_viewing-ri-in-a-web-browser.html</id>
    <title type="text">Viewing RI in a web browser</title>
    <updated>23 Jul 09 00:00</updated>
    <content type="html">&lt;p&gt;I&amp;#39;m a big fan of the Firefox keyword search. For example I have
keywords for &lt;a href=&quot;http://dict.leo.org&quot;&gt;LEO&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt; and &lt;a href=&quot;http://www.nongnu.org/man2html&quot;&gt;Man pages&lt;/a&gt;. Sometimes I
want to look up API documentation in Ruby and typing &lt;code&gt;ri camelize&lt;/code&gt;
into the address bar and viewing the documentation as web page seems
to be quite natural for me. So I wrote a quick and dirty cgi, which
calls RI and outputs HTML.&lt;/p&gt;

&lt;h3&gt;CGI script&lt;/h3&gt;

&lt;p&gt;I&amp;#39;ve put the following code in file named
&lt;code&gt;/usr/lib/cgi-bin/ri.b&lt;/code&gt;. This is the default location for cgi scripts
on my system for Apache.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env ruby

require &amp;#39;rdoc/ri/ri_driver&amp;#39;
require &amp;#39;rubygems&amp;#39;

print &amp;quot;Content-type: text/html\r\n\r\n&amp;quot;

ARGV &amp;lt;&amp;lt; &amp;#39;-f&amp;#39; &amp;lt;&amp;lt; &amp;#39;html&amp;#39;

ri = RiDriver.new

print &amp;#39;&amp;lt;html&amp;gt;&amp;lt;body style=&amp;quot;width:600px; margin:auto; padding:20px&amp;quot;&amp;gt;&amp;#39;
ri.process_args
print &amp;#39;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script does the same thing as if you typed &lt;code&gt;ri somequery -f
html&lt;/code&gt;. I put some HTML around it to give it some style, but that&amp;#39;s it.&lt;/p&gt;

&lt;h3&gt;The Keyword Search&lt;/h3&gt;

&lt;p&gt;So I want to type &lt;code&gt;ri String.capitalize&lt;/code&gt; and the browser should send a
request to &lt;code&gt;http://localhost/cgi-bin/ri.rb?String.capitalize&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just add a new bookmark and give it the keyword &lt;code&gt;ri&lt;/code&gt; and use as url
this one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; http://localhost/cgi-bin/ri.rb?%s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;#39;re done. One thing I would like to improve is to add hyperlinks
to the output. For example viewing the documentation of a class brings
up all documented methods. Each of them should be a link to the actual
documentation. Probably some monkey patching on the &lt;a href=&quot;http://rdoc.rubyforge.org/classes/RDoc/RI/HtmlFormatter.html&quot;&gt;HtmlFormatter&lt;/a&gt;
class would do the job.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de2009_07_23_viewing-ri-in-a-web-browser.html" type="text/html" />
    <published>23 Jul 09 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2009_04_25_kontrol-a-micro-framework.html</id>
    <title type="text">Kontrol - a micro framework</title>
    <updated>25 Apr 09 00:00</updated>
    <content type="html">&lt;p&gt;Kontrol is a small web framework written in Ruby, which runs directly
on &lt;a href=&quot;http://github.com/chneukirchen/rack&quot;&gt;Rack&lt;/a&gt;. It provides a simple pattern matching algorithm for routing
and uses GitStore as data storage.&lt;/p&gt;

&lt;p&gt;All examples can be found in the &lt;a href=&quot;http://github.com/georgi/kontrol/tree/master/examples&quot;&gt;examples folder&lt;/a&gt; of the kontrol
project, which is hosted on &lt;a href=&quot;http://github.com/georgi/kontrol&quot;&gt;this github page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;
Kontrol has its own &lt;a href=&quot;/kontrol&quot;&gt;project page&lt;/a&gt; now!
Please look for current information there.
&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Quick Start&lt;/h3&gt;

&lt;p&gt;Create a file named &lt;code&gt;hello_world.ru&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;kontrol&amp;#39;

class HelloWorld &amp;lt; Kontrol::Application
  map do
    get &amp;#39;/&amp;#39; do
      &amp;quot;Hello World!&amp;quot; 
    end
  end
end

run HelloWorld.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup hello_world.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Browse to &lt;code&gt;http://localhost:9292&lt;/code&gt; and you will see &amp;ldquo;Hello World&amp;rdquo;.&lt;/p&gt;

&lt;h3&gt;Features&lt;/h3&gt;

&lt;p&gt;Kontrol is just a thin layer on top of Rack. It provides a routing
algorithm, a simple template mechanism and some convenience stuff to
work with &lt;a href=&quot;http://github.com/georgi/git_store&quot;&gt;GitStore&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A Kontrol application is a class, which provides some context to the
defined actions. You will probably use these methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;request: the Rack request object&lt;/li&gt;
&lt;li&gt;response: the Rack response object&lt;/li&gt;
&lt;li&gt;params: union of GET and POST parameters&lt;/li&gt;
&lt;li&gt;cookies: shortcut to request.cookies&lt;/li&gt;
&lt;li&gt;session: shortcut to &lt;code&gt;request.env[&amp;#39;rack.session&amp;#39;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;redirect(path): renders a redirect response to specified path&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Routing&lt;/h3&gt;

&lt;p&gt;Routing is just as simple as using regular expressions with
groups. Each group will be provided as argument to the block.&lt;/p&gt;

&lt;p&gt;Create a file named &lt;code&gt;routing.ru&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;kontrol&amp;#39;

class Routing &amp;lt; Kontrol::Application
  map do
    get &amp;#39;/pages/(.*)&amp;#39; do |name|
      &amp;quot;This is the page #{name}!&amp;quot;
    end

    get &amp;#39;/(\d*)/(\d*)&amp;#39; do |year, month|
      &amp;quot;Archive for #{year}/#{month}&amp;quot;
    end
  end
end

run Routing.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run this application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup routing.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will now see, how regex groups and parameters are related. For
example if you browse to &lt;code&gt;localhost:9292/2008/12&lt;/code&gt;, the app will
display &lt;code&gt;Archive for 2008/12&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Nested Routes&lt;/h3&gt;

&lt;p&gt;Routes can be nested. This way you can avoid repeating patterns and
define handlers for a set of HTTP verbs. Each handler will be called
with the same arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;kontrol&amp;#39;

class Nested &amp;lt; Kontrol::Application
  map do
    map &amp;#39;/blog&amp;#39; do
      get &amp;#39;/archives&amp;#39; do
        &amp;quot;The archives!&amp;quot;
      end
    end

    map &amp;#39;/(.*)&amp;#39; do
      get do |path|
        &amp;quot;&amp;lt;form method=&amp;#39;post&amp;#39;&amp;gt;&amp;lt;input type=&amp;#39;submit&amp;#39;/&amp;gt;&amp;lt;/form&amp;gt;&amp;quot;
      end

      post do |path|
        &amp;quot;You posted to #{path}&amp;quot;
      end
    end
  end
end

run Nested.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run this app like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup nested.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second route catches all paths except the &lt;code&gt;/blog&lt;/code&gt; route. Inside
the second route there are two different handlers for &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;
actions.&lt;/p&gt;

&lt;p&gt;So if you browse to &lt;code&gt;/something&lt;/code&gt;, you will see a submit button. After
submitting you will see the result of the second handler.&lt;/p&gt;

&lt;h3&gt;Templates&lt;/h3&gt;

&lt;p&gt;Rendering templates is as simple as calling a template file with some
parameters, which are accessible inside the template as instance
variables. Additionally you will need a layout template.&lt;/p&gt;

&lt;p&gt;Create a template named &lt;code&gt;templates/layout.rhtml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%= @content %&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now another template named &lt;code&gt;templates/page.rhtml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;%= @title %&amp;gt;&amp;lt;/h1&amp;gt;
&amp;lt;%= @body %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a templates.ru file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Templates &amp;lt; Kontrol::Application
  map do
    get &amp;#39;/(.*)&amp;#39; do |name|
      render &amp;quot;page.rhtml&amp;quot;, :title =&amp;gt; name.capitalize, :body =&amp;gt; &amp;quot;This is the body!&amp;quot;
    end
  end
end

run Templates.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run this example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup templates.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you browse to any path on &lt;code&gt;localhost:9292&lt;/code&gt;, you will see the
rendered template. Note that the title and body parameters have been
passed to the &lt;code&gt;render&lt;/code&gt; call.&lt;/p&gt;

&lt;h3&gt;Using GitStore&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/georgi/git_store&quot;&gt;GitStore&lt;/a&gt; is another library, which allows you to store code and
data in a convenient way in a git repository. The repository is
checked out into memory and any data may be saved back into the
repository.&lt;/p&gt;

&lt;p&gt;Install &lt;a href=&quot;http://github.com/georgi/git_store&quot;&gt;GitStore&lt;/a&gt; and &lt;a href=&quot;http://github.com/mojombo/grit&quot;&gt;Grit&lt;/a&gt; by:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem sources -a http://gems.github.com (you only have to do this once)
$ sudo gem install mojombo-grit georgi-git_store
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create a Markdown file name &lt;code&gt;pages/index.md&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello World
===========

This is the **Index** page!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have now a simple page, which should be rendered as response. We
create a simple app in a file &lt;code&gt;git_app.ru&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;bluecloth&amp;#39;

class GitApp &amp;lt; Kontrol::Application
  map do
    get &amp;#39;/(.*)&amp;#39; do |name|
      BlueCloth.new(store[&amp;#39;pages&amp;#39;, name + &amp;#39;.md&amp;#39;]).to_html
    end
  end
end

run GitApp.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add all these files to your repo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init
git add pages/index.md
git commit -m &amp;#39;init&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the app:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup git_app.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Browse to &lt;code&gt;http://localhost:9292/index&lt;/code&gt; and you will see the rendered
page generated from the markdown file.&lt;/p&gt;

&lt;p&gt;This application runs straight from the git repository. You can delete
all files except the rackup file and the app will still serve the page
from your repo.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de2009_04_25_kontrol-a-micro-framework.html" type="text/html" />
    <published>25 Apr 09 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2009_04_22_rackdav-web-authoring-for-rack.html</id>
    <title type="text">RackDAV - Web Authoring for Rack</title>
    <updated>22 Apr 09 00:00</updated>
    <content type="html">&lt;p&gt;RackDAV is Handler for &lt;a href=&quot;http://github.com/chneukirchen/rack&quot;&gt;Rack&lt;/a&gt;, which allows content authoring over
HTTP. RackDAV brings its own file backend, but other backends are
possible by subclassing RackDAV::Resource.&lt;/p&gt;

&lt;h2&gt;Install&lt;/h2&gt;

&lt;p&gt;Just install the gem from github:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem sources -a http://gems.github.com
$ sudo gem install georgi-rack_dav
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Quickstart&lt;/h2&gt;

&lt;p&gt;If you just want to share a folder over WebDAV, you can just start a
simple server with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rack_dav
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will start a WEBrick server on port 3000, which you can connect
to without authentication.&lt;/p&gt;

&lt;h2&gt;Rack Handler&lt;/h2&gt;

&lt;p&gt;Using RackDAV inside a rack application is quite easy. A simple rackup
script looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;rubygems&amp;#39;
require &amp;#39;rack_dav&amp;#39;

use Rack::CommonLogger

run RackDAV::Handler.new(&amp;#39;/path/to/docs&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Implementing your own WebDAV resource&lt;/h2&gt;

&lt;p&gt;RackDAV::Resource is an abstract base class and defines an interface
for accessing resources.&lt;/p&gt;

&lt;p&gt;Each resource will be initialized with a path, which should be used to
find the real resource.&lt;/p&gt;

&lt;p&gt;RackDAV::Handler needs to be initialized with the actual resource class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RackDAV::Handler.new(:resource_class =&amp;gt; MyResource)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RackDAV needs some information about the resources, so you have to
implement following methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;children&lt;/strong&gt;: If this is a collection, return the child resources.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;collection?&lt;/strong&gt;: Is this resource a collection?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;exist?&lt;/strong&gt;: Does this recource exist?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;creation_date&lt;/strong&gt;: Return the creation time.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;last_modified&lt;/strong&gt;: Return the time of last modification.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;last_modified=(time)&lt;/strong&gt;: Set the time of last modification.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;etag&lt;/strong&gt;: Return an Etag, an unique hash value for this resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;content_type&lt;/strong&gt;: Return the mime type of this resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;content_length&lt;/strong&gt;: Return the size in bytes for this resource.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most importantly you have to implement the actions, which are called
to retrieve and change the resources:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;get(request, response)&lt;/strong&gt;: Write the content of the resource to the response.body.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;put(request, response)&lt;/strong&gt;: Save the content of the request.body.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;post(request, response)&lt;/strong&gt;: Usually forbidden.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;delete&lt;/strong&gt;: Delete this resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;copy(dest)&lt;/strong&gt;: Copy this resource to given destination resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;move(dest)&lt;/strong&gt;: Move this resource to given destination resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;make_collection&lt;/strong&gt;: Create this resource as collection.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note, that it is generally possible, that a resource object is
instantiated for a not yet existing resource.&lt;/p&gt;

&lt;p&gt;For inspiration you should have a look at the FileResource
implementation. Please let me now, if you are going to implement a new
type of resource.&lt;/p&gt;

&lt;h3&gt;RackDAV on GitHub&lt;/h3&gt;

&lt;p&gt;Download or fork the project on its &lt;a href=&quot;http://github.com/georgi/rack_dav&quot;&gt;Github page&lt;/a&gt;&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de2009_04_22_rackdav-web-authoring-for-rack.html" type="text/html" />
    <published>22 Apr 09 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2009_01_12_git-store-using-git-as-versioned-data-store-in-ruby.html</id>
    <title type="text">Git Store - using Git as versioned data store in Ruby</title>
    <updated>12 Jan 09 00:00</updated>
    <content type="html">&lt;p&gt;GitStore is a small Ruby library, providing an easy interface to the
version control system &lt;a href=&quot;http://git.or.cz/&quot;&gt;Git&lt;/a&gt;. It aims to use Git as a versioned
data store much like the well known PStore. Basically GitStore checks
out the repository into a in-memory representation, which can be
modified and finally committed. In this way your data is stored in a
folder structure and can be checked out and examined, but the
application may access the data in a convenient hash-like way. This
library is based on &lt;a href=&quot;http://github.com/mojombo/grit&quot;&gt;Grit&lt;/a&gt;, the main technology behind &lt;a href=&quot;http://github.com/&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;
GitStore has its own &lt;a href=&quot;/gitstore&quot;&gt;project page&lt;/a&gt; now!
Please look for current information there.
&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Installation&lt;/h3&gt;

&lt;p&gt;GitStore can be installed as gem easily, if you have RubyGems 1.2.0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem sources -a http://gems.github.com (you only have to do this once)
$ sudo gem install mojombo-grit georgi-git_store
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;#39;t have RubyGems 1.2.0, you may download the package on the
&lt;a href=&quot;http://www.newartisans.com/blog_files/git.versioned.data.store.php&quot;&gt;github page&lt;/a&gt; and build the gem yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem build git_store.gemspec
$ sudo gem install git_store
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Usage Example&lt;/h3&gt;

&lt;p&gt;First thing you should do, is to initialize a new git repository.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir test
$ cd test
$ git init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can instantiate a GitStore instance and store some data. The
data will be serialized depending on the file extension. So for YAML
storage you can use the &amp;#39;yml&amp;#39; extension:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class WikiPage &amp;lt; Struct.new(:author, :title, :body); end
class User &amp;lt; Struct.new(:name); end

store = GitStore.new(&amp;#39;.&amp;#39;)

store[&amp;#39;users/matthias.yml&amp;#39;] = User.new(&amp;#39;Matthias&amp;#39;)
store[&amp;#39;pages/home.yml&amp;#39;] = WikiPage.new(&amp;#39;matthias&amp;#39;, &amp;#39;Home&amp;#39;, &amp;#39;This is the home page...&amp;#39;)

store.commit &amp;#39;Added user and page&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that directories will be created automatically.&lt;/p&gt;

&lt;p&gt;Another way to access a path is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;store[&amp;#39;config&amp;#39;, &amp;#39;wiki.yml&amp;#39;] = { &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;My Personal Wiki&amp;#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally you can access the git store as a Hash of Hashes, but in this
case you have to create the Tree objects manually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;store[&amp;#39;users&amp;#39;] = GitStore::Tree.new
store[&amp;#39;users&amp;#39;][&amp;#39;matthias.yml&amp;#39;] = User.new(&amp;#39;Matthias&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Where is my data?&lt;/h3&gt;

&lt;p&gt;When you call the &lt;code&gt;commit&lt;/code&gt; method, your data is written back straight
into the git repository. No intermediate file representation. So if
you want to look into your data, you can use some git browser like
&lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-gui.html&quot;&gt;git-gui&lt;/a&gt; or just checkout the files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Iteration&lt;/h3&gt;

&lt;p&gt;Iterating over the data objects is quite easy. Furthermore you can
iterate over trees and subtrees, so you can partition your data in a
meaningful way. For example you may separate the config files and the
pages of a wiki:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;store[&amp;#39;pages/home.yml&amp;#39;] = WikiPage.new(&amp;#39;matthias&amp;#39;, &amp;#39;Home&amp;#39;, &amp;#39;This is the home page...&amp;#39;)
store[&amp;#39;pages/about.yml&amp;#39;] = WikiPage.new(&amp;#39;matthias&amp;#39;, &amp;#39;About&amp;#39;, &amp;#39;About this site...&amp;#39;)
store[&amp;#39;pages/links.yml&amp;#39;] = WikiPage.new(&amp;#39;matthias&amp;#39;, &amp;#39;Links&amp;#39;, &amp;#39;Some useful links...&amp;#39;)
store[&amp;#39;config/wiki.yml&amp;#39;] = { &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;My Personal Wiki&amp;#39; }

store.each { |obj| ... } # yields all pages and the config hash
store[&amp;#39;pages&amp;#39;].each { |page| ... } # yields only the pages
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Serialization&lt;/h3&gt;

&lt;p&gt;Serialization is dependent on the filename extension. You can add more
handlers if you like, the interface is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class YAMLHandler
  def read(id, name, data)
    YAML.load(data)
  end

  def write(data)
    data.to_yaml
  end    
end

GitStore::Handler[&amp;#39;yml&amp;#39;] = YAMLHandler.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Shinmun uses its own handler for files with &lt;code&gt;md&lt;/code&gt; extension:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PostHandler
  def read(name, data)
    Post.new(:filename =&amp;gt; name, :src =&amp;gt; data)
  end

  def write(post)
    post.dump
  end    
end

GitStore::Handler[&amp;#39;md&amp;#39;] = PostHandler.new
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Related Work&lt;/h3&gt;

&lt;p&gt;John Wiegley already has done &lt;a href=&quot;http://www.newartisans.com/blog_files/git.versioned.data.store.php&quot;&gt;something similar for Python&lt;/a&gt;. His
implementation has its own git interface, GitStore uses the wonderful
&lt;a href=&quot;http://github.com/mojombo/grit&quot;&gt;Grit&lt;/a&gt; library.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de2009_01_12_git-store-using-git-as-versioned-data-store-in-ruby.html" type="text/html" />
    <published>12 Jan 09 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de2008_12_24_using-javascript-templates-for-a-delicious-sidebar.html</id>
    <title type="text">Using Javascript Templates for a Delicious Sidebar</title>
    <updated>24 Dec 08 00:00</updated>
    <content type="html">&lt;p&gt;Processing JSON data from an external source with Javascript templates
is a natural fit. Create a template inside your &lt;em&gt;HTML Document&lt;/em&gt; by
adding class names and variables and write a few lines for fetching
the &lt;em&gt;JSON&lt;/em&gt;, that&amp;#39;s all. This tutorial is an example for my Javascript
Template Engine called &lt;strong&gt;&lt;a href=&quot;http://www.matthias-georgi.de/2008/9/patroon-a-javascript-template-engine-part-2.html&quot;&gt;Patroon&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;Writing the template&lt;/h3&gt;

&lt;p&gt;In my sidebar you can see the result of my example. My latest
bookmarks are shown as a list. Quite simple. The template looks like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;bookmarks&amp;quot;&amp;gt;
  &amp;lt;ul id=&amp;quot;bookmarks-template&amp;quot;&amp;gt;
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;{u}&amp;quot;&amp;gt;{d}&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There a two variables here &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;. I don&amp;#39;t know if &lt;em&gt;Delicious&lt;/em&gt;
wants to save some bytes here, but descriptive names wouldn&amp;#39;t hurt in
this case. &lt;code&gt;u&lt;/code&gt; is refering to the url of the bookmark and &lt;code&gt;d&lt;/code&gt; is the
title. We are expanding an array of bookmarks into the &lt;code&gt;li&lt;/code&gt; element,
which is marked by the class name &lt;code&gt;bookmark&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Fetching the JSON Feed&lt;/h3&gt;

&lt;p&gt;The Feed resides on a different domain, so we have to use a &lt;code&gt;script&lt;/code&gt;
tag to fetch the data. This is because of security restrictions, which
limits &lt;em&gt;AJAX&lt;/em&gt; calls to the same domain of the current web page.&lt;/p&gt;

&lt;p&gt;The feed url for your bookmarks looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://feeds.delicious.com/v2/json/{username}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to fetch some of the other feeds, just look at the
&lt;a href=&quot;http://delicious.com/help/json/&quot;&gt;documentation&lt;/a&gt;, which describes 18 different feed types.&lt;/p&gt;

&lt;p&gt;A very useful option in our case is to provide a callback function,
which gets called after the &lt;em&gt;JSON&lt;/em&gt; script was loaded. We define
&lt;code&gt;renderBookmarks&lt;/code&gt; as our callback.&lt;/p&gt;

&lt;p&gt;The following code inserts the script tag to load the &lt;em&gt;Delicious&lt;/em&gt;
&lt;em&gt;JSON&lt;/em&gt; feed of my bookmarks. This is done when the page is loaded:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function() {
    var head = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0];
    var script = document.createElement(&amp;#39;script&amp;#39;);

    script.setAttribute(&amp;quot;src&amp;quot;, &amp;quot;http://feeds.delicious.com/v2/json/matthias_georgi?callback=renderBookmarks&amp;quot;);
    script.setAttribute(&amp;quot;type&amp;quot;, &amp;quot;text/javascript&amp;quot;);

    head.appendChild(script);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#39;m using jQuery here for the window load event. Other libraries would
need some other api call.&lt;/p&gt;

&lt;h3&gt;Rendering the JSON data&lt;/h3&gt;

&lt;p&gt;The code for rendering consists of just two lines. First we are
instantiating the Template. We have to provide the id of the template
node (the template is part of your document).&lt;/p&gt;

&lt;p&gt;Second we expand the template using the jQuery helper. The variable
&lt;code&gt;data&lt;/code&gt; contains just the array of bookmarks. To match the &lt;code&gt;li&lt;/code&gt; element
of the template, which has the class name &lt;code&gt;bookmark&lt;/code&gt;, we must set the
template variable &lt;code&gt;bookmark&lt;/code&gt; to hold the bookmarks array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function renderBookmarks(data) {
  var template = new Template(&amp;#39;bookmarks-template&amp;#39;);
  $(&amp;#39;.bookmarks&amp;#39;).expand(template, { bookmark: data });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Result&lt;/h3&gt;

&lt;p&gt;The resulting &lt;em&gt;HTML&lt;/em&gt; of my bookmark sidebar looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;bookmarks&amp;quot;&amp;gt;
  &amp;lt;ul id=&amp;quot;bookmarks-template&amp;quot;&amp;gt;            
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;http://delicious.com/help/json/&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;delicious/help/feeds&amp;lt;/span&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;http://code.google.com/apis/youtube/reference.html&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;Reference Guide: Data API Protocol - YouTube APIs and Tools - Google Code&amp;lt;/span&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;http://rewrite.rubyforge.org/&amp;quot;&amp;gt;
      &amp;lt;span&amp;gt;rewrite&amp;lt;/span&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;http://www.infoq.com/interviews/Rewrite-Reginald-Braithwaite&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;InfoQ: Reginald Braithwaite on Rewrite&amp;lt;/span&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may wonder, why there are extra span elements around the variable
expansions. Well this is necessary for inserting &lt;em&gt;HTML&lt;/em&gt; from a
variable. If I want to replace a text node with some &lt;em&gt;HTML&lt;/em&gt;, I have to
insert a &lt;em&gt;span&lt;/em&gt; element and use the &lt;code&gt;innerHTML&lt;/code&gt; property. If you know
something better, please let me know.&lt;/p&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Using &lt;em&gt;Javascript&lt;/em&gt; templates with &lt;em&gt;JSON&lt;/em&gt; feeds is simple and
efficient. You write standards-compliant &lt;em&gt;HTML&lt;/em&gt; sprinkled with some
variables and expand this with some &lt;em&gt;JSON&lt;/em&gt; data, that&amp;#39;s all.&lt;/p&gt;

&lt;h3&gt;Related Work&lt;/h3&gt;

&lt;p&gt;There are some other libraries for javascript templating, which are
related to &lt;strong&gt;Patroon&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://beebole.com/pure/&quot;&gt;PURE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jsrepeater.devprog.com/&quot;&gt;jsRepeater&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/trimpath/wiki/JavaScriptTemplates&quot;&gt;TrimPath&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://embeddedjs.com/&quot;&gt;EmbeddedJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Patroon is probably the smallest templating solution around and
consists only of 130 lines of code.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de2008_12_24_using-javascript-templates-for-a-delicious-sidebar.html" type="text/html" />
    <published>24 Dec 08 00:00</published>
  </entry>
</feed>